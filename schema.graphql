# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
}

type AggregateUser {
    count: Int!
}

type BatchPayload {
    "The number of nodes that have been affected by the Batch operation."
    count: Long!
}

type Mutation {
    createUser(data: UserCreateInput!): User!
    deleteManyUsers(where: UserWhereInput): BatchPayload!
    deleteUser(where: UserWhereUniqueInput!): User
    updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Query {
    "Fetches an object given its ID"
    node(
        #The ID of an object
        id: ID!
    ): Node
    user(where: UserWhereUniqueInput!): User
    users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User]!
    usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type Subscription {
    user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User implements Node {
    createdAt: DateTime!
    id: ID!
    name: String!
}

"A connection to a list of items."
type UserConnection {
    aggregate: AggregateUser!
    "A list of edges."
    edges: [UserEdge]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type UserPreviousValues {
    createdAt: DateTime!
    id: ID!
    name: String!
}

type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    previousValues: UserPreviousValues
    updatedFields: [String!]
}

enum MutationType {
    CREATED
    DELETED
    UPDATED
}

enum UserOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
}

input UserCreateInput {
    id: ID
    name: String!
}

input UserSubscriptionWhereInput {
    "Logical AND on all given filters."
    AND: [UserSubscriptionWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserSubscriptionWhereInput!]
    "Logical OR on all given filters."
    OR: [UserSubscriptionWhereInput!]
    "The subscription event gets dispatched when it's listed in mutation_in"
    mutation_in: [MutationType!]
    node: UserWhereInput
    "The subscription event gets only dispatched when one of the updated fields names is included in this list"
    updatedFields_contains: String
    "The subscription event gets only dispatched when all of the field names included in this list have been updated"
    updatedFields_contains_every: [String!]
    "The subscription event gets only dispatched when some of the field names included in this list have been updated"
    updatedFields_contains_some: [String!]
}

input UserUpdateInput {
    name: String
}

input UserUpdateManyMutationInput {
    name: String
}

input UserWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values greater than the given value."
    id_gt: ID
    "All values greater than or equal the given value."
    id_gte: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values less than the given value."
    id_lt: ID
    "All values less than or equal the given value."
    id_lte: ID
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string."
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values greater than the given value."
    name_gt: String
    "All values greater than or equal the given value."
    name_gte: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values less than the given value."
    name_lt: String
    "All values less than or equal the given value."
    name_lte: String
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string."
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
}

input UserWhereUniqueInput {
    id: ID
}


scalar DateTime

"The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long